Request receiving over SUB sockets:
	- Protocol definition (we need a prefixed message to be able to define server groups via multicast)
Benchmark for python and C++ client
Extend C++ client to support all requests
Add API classes (REQ/REP only or PUSH/PUB too?) to external protocol doc (mostly done, check if finished)
Advanced options for table opening, especially n-bits-per-key bloom filters
Dynamic spawning of update/read threads (low priority, better implement postoffice queueing first)
DEB packaging
Post-office-style read-and-update queues, but check performance beforehand
	- Basic idea: PULL socket on the main router Thread, threads write a thread identifier to the socket when they are (almost) finished
	- To avoid clogging up the main router thread with loads of messages maybe scheduling should be moved to a separate thread
	- Encapsulate in UpdateWorker/ReadWorker classes
EASY: Use raw ZMQ API (not CZMQ zmsg_t*) in the Logger server.
Check for memleaks carefully, automate valgrind memcheck
Add automated unit test of all major features. Shall use variable table numbers
BMH data filter (like in scan requests) also for CSP AP Jobs (fairly simple, if you know what you're doing)
The docs shall really make clear that the HTTP API is SLOW. REALLY SLOW (not really, it's f*cking fast actually, but it's slow compared to ZMQ). It's not even intended to be fast. ZMQ API ist intended to be fast.
Copying from one table to another (important for PULL-based write load balancing)
Moving table from one ID to another:
	- Should be implemented on filesystem level
		- Close, Truncate, Move directory
	- Faster than copying
Multitable defragmentation (difficult), shall work across YakDB instances in the future (cluster defrag, event more difficult). O(n) algorithms in respect to n(kv pairs) only!
	- Need an algorithm
		- Shall not assume the data fits into memory
		- Shall not assume the data is evenly distributed
		- May assume bidirectional communication
Centralized KV controller with keyspace-division (also related to defragmentation)
Map-Reduce Kernel:
	- LLVM JIT interface: Receive LLVM BC over ZMQ and execute that in spawned threads
	- Protocol definitions (partially done)
	- Architectural diagram
	- Functionality to scan over a KV table (snapshot!) and pipe that into:
		* Any ZMQ PULL socket (especially multiple ones)
		* Directly to LLVM (probably over inproc:// PUSH/PULL)
Documentation
	- Tutorials
	- HOWTOs
